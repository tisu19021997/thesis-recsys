def re_rank(recommend_list: [tuple], user_profile: [tuple], short_head_items: set, long_tail_items: set, train_set,
            epochs=10, reg=.35, binary=False):
    """Returns a re-ranked recommendation list from a given recommendation list using xQuAD algorithm.
    Args:
        recommend_list (list of tuple): Recommendation list generated by the base algorithm [(raw_iid, rating)].
        user_profile (list of tuple): User's ratings [(inner_iid, rating)].
        short_head_items (set): Items that are in short-head.
        long_tail_items (set): Items that area in long-tail.
        train_set: Training set, `surprise.Trainset`.
        epochs (int): Number of items in the re-ranked recommendation list,
         it is also how many time the algorithms loops.
        reg (float or int): Regularization parameter.
        binary (bool): If true, use Binary xQuAD. Else, Smooth xQuAD.

    References:
        Managing Popularity Bias in Recommender Systems with Personalized Re-ranking https://arxiv.org/pdf/1901.07555.pdf
    """
    re_ranked_list = []
    scores = []

    for _ in range(epochs):
        best_score = -float('inf')
        best_item = None

        for rec in recommend_list:
            # current item's id
            v = rec[0]

            if v in re_ranked_list:
                continue

            # item's predicted rating
            p_vu = rec[1]

            score = (1 - reg) * p_vu
            summation = 0

            # for each category
            for c in (short_head_items, long_tail_items):
                # how much user is interested in short head items versus long tail items
                p_cu = sum((train_set.to_raw_iid(r[0]) in c for r in user_profile)) / len(user_profile)

                if binary:
                    # if item `i` in list `S` cover category `c`, then `p_ic_s` = 1, otherwise 0 (Binary xQuAD)
                    p_ic_s = sum((1 if i in c else 0 for i in re_ranked_list))
                else:
                    # ratio of items in list `S that covers category `c` (Smooth xQuAD)
                    p_ic_s = sum((i in c for i in re_ranked_list)) / len(re_ranked_list) if len(
                        re_ranked_list) != 0 else 0

                # 1 if item in category `c`, otherwise 0
                p_vc = 1 if v in c else 0
                summation += p_cu * p_vc * (1 - p_ic_s)

            score += reg * summation

            # keep track of the item with the best score
            if score > best_score:
                best_score = score
                best_item = v

        scores.append(best_score)
        re_ranked_list.append(best_item)

    return tuple(zip(re_ranked_list, scores))


def xquad(recommendation, user_profile, short_items, long_items, trainset, n_epochs=10, reg=.35, binary=False):
    # In case there are not enough items in the recommendation list
    n_epochs = min(len(recommendation), n_epochs)

    final_result = []
    S = []

    # In order to select the next item to add to S,
    # we compute a score for each item in R\S (in R not in S)
    for n in range(n_epochs):
        # For selecting the best score
        best_score = 0
        best_item = None

        for r in recommendation:
            v = r[0]
            p_vu = r[1]

            # v already in S, so skip it.
            if v in S:
                continue

            p_vu = (p_vu - 1.0) / (5.0 - 1.0)
            score = (1 - reg) * (p_vu)

            summation = 0

            for d in (short_items, long_items):
                # Because P(v|c)is 0 if `v` not in category `d`
                if v not in d:
                    summation += 0
                    continue

                # The ratio of items in the user profile which belong to category `d`
                p_du = sum([item in d for item in user_profile]) / len(user_profile)

                # Binary - equals to 1 when item `i` in list `S` already covers category `d`, 0 otherwise
                if binary:
                    p_id_s = 1 if any([i in d for i in S]) else 0
                else:
                    # Smooth - the ratio of items in list `S` that covers category `d`
                    p_id_s = sum([i in d for i in S]) / len(S) if len(S) > 0 else 0

                # pi = (1 - P(i|d, S))
                pi = 1 - p_id_s

                summation += p_du * pi

            score += reg * summation

            if score > best_score:
                best_score = score
                best_item = v

        S.append(best_item)
        final_result.append((best_item, best_score))

    return tuple(final_result)
