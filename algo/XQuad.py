def re_rank(recommend_list: [tuple], user_profile: [tuple], short_head_items: set, long_tail_items: set, train_set,
            epochs=10, reg=.35, binary=False):
    """Returns a re-ranked recommendation list from a given recommendation list using xQuAD algorithm.
    Args:
        recommend_list (list of tuple): Recommendation list generated by the base algorithm [(raw_iid, rating)].
        user_profile (list of tuple): User's ratings [(inner_iid, rating)].
        short_head_items (set): Items that are in short-head.
        long_tail_items (set): Items that area in long-tail.
        train_set: Training set, `surprise.Trainset`.
        epochs (int): Number of items in the re-ranked recommendation list,
         it is also how many time the algorithms loops.
        reg (float or int): Regularization parameter.
        binary (bool): If true, use Binary xQuAD. Else, Smooth xQuAD.

    References:
        Managing Popularity Bias in Recommender Systems with Personalized Re-ranking https://arxiv.org/pdf/1901.07555.pdf
    """
    re_ranked_list = []
    scores = []

    for _ in range(epochs):
        best_score = -float('inf')
        best_item = None

        for rec in recommend_list:
            # current item's id
            v = rec[0]

            if v in re_ranked_list:
                continue

            # item's predicted rating
            p_vu = rec[1]

            score = (1 - reg) * p_vu
            summation = 0

            # for each category
            for c in (short_head_items, long_tail_items):
                # how much user is interested in short head items versus long tail items
                p_cu = sum((train_set.to_raw_iid(r[0]) in c for r in user_profile)) / len(user_profile)

                if binary:
                    # if item `i` in list `S` cover category `c`, then `p_ic_s` = 1, otherwise 0 (Binary xQuAD)
                    p_ic_s = sum((1 if i in c else 0 for i in re_ranked_list))
                else:
                    # ratio of items in list `S that covers category `c` (Smooth xQuAD)
                    p_ic_s = sum((i in c for i in re_ranked_list)) / len(re_ranked_list) if len(
                        re_ranked_list) != 0 else 0

                # 1 if item in category `c`, otherwise 0
                p_vc = 1 if v in c else 0
                summation += p_cu * p_vc * (1 - p_ic_s)

            score += reg * summation

            # keep track of the item with the best score
            if score > best_score:
                best_score = score
                best_item = v

        scores.append(best_score)
        re_ranked_list.append(best_item)

    return tuple(zip(re_ranked_list, scores))
